(.) : A -> (A -> B) -> B forall {A, B} =
    | a, f => f(a)

infixl 10 .

data None
data Some(A) forall { A }

type Option = None | Some[A] forall { A }

data Nil
data A /\ B forall { A, B }

infixr 5 /\

type List = Nil | A /\ List[A] forall { A }

interface Map where
    map : Self[A] -> (A -> B) -> Self[B] forall { A, B }

map : List[A] -> (A -> B) -> List[B] forall { A, B } =
    | Nil, _ => Nil
    | h /\ t, f => h.f /\ t.map(f)

map : Option[A] -> (A -> B) -> Option[B] forall { A, B } =
    | None, _ => None
    | Some(a), f => Some(a.f)

interface Flatten where
    flatten : Self[Self[A]] -> Self[A] forall { A }

append : List[A] -> List[A] -> List[A] forall { A } =
    | Nil, ys => ys
    | h /\ t, ys => h /\ t.append(ys)

flatten : Option[Option[A]] -> Option[A] forall { A } =
    | None => None
    | Some(None) => None
    | Some(Some(a)) => Some(a)

flatten : List[List[A]] -> List[A] forall { A } =
    | Nil => Nil
    | h /\ t => h.append(t.flatten)

flat_map : F[A] -> (A -> F[B]) -> F[B] forall { F: Map & Flatten, A, B } =
    | x, f => x.map(f).flatten

main : () -> () =
    | () => do
        None.flat_map(| a => None)
        Some("ok").flat_map(| a => None)
        Some("ok").flat_map(| a => Some(a.println))
        ()
