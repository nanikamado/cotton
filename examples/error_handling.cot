data Err(A) forall { A }
data Ok(A) forall { A }

type Result = Ok[A] | Err[B] forall { A, B }

to_string : Result[A, E] -> String forall { A : ToString, E : ToString } =
    | Ok(a) => "Ok(" <> a.to_string <> ")"
    | Err(e) => "Err(" <> e.to_string <> ")"

map : Result[A, C] -> (A -> B) -> Result[B, C] forall { A, B, C } =
    | Err(a), _ => Err(a)
    | Ok(a), f => Ok(a.f)

flatten : Result[Result[A, E1], E2] -> Result[A, E1 | E2] forall { A, E1, E2 } =
    | Ok(a) => a
    | Err(a) => Err(a)

data Error1
data Error2
data Error3

to_string : (Error1 | Error2 | Error3) -> String =
    | Error1 => "Error1"
    | Error2 => "Error2"
    | Error3 => "Error3"
to_string = | () => "()"

may_fail_1 : () -> Result[(), Error1] = | () => Err(Error1)
may_fail_2 : () -> Result[(), Error2] = | () => Err(Error2)
may_fail_3 : () -> Result[(), Error3] = | () => Ok(())

do_1_2_3 : () -> Result[(), Error1 | Error2 | Error3] =
    | () => do
        may_fail_1(())?
        may_fail_2(())?
        may_fail_3(())?
        Ok(())

main : () -> () =
    | () => do
        do_1_2_3(()).puts
        ()
